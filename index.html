<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"flyginger.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="zenk&#39;s blog">
<meta property="og:url" content="https://flyginger.github.io/index.html">
<meta property="og:site_name" content="zenk&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zenk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://flyginger.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>zenk's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">zenk's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zenk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://flyginger.github.io/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zenk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zenk's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zenk's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">DPDK Programmer's Guide笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-04 16:49:12" itemprop="dateCreated datePublished" datetime="2023-08-04T16:49:12+00:00">2023-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-14 07:08:19" itemprop="dateModified" datetime="2023-08-14T07:08:19+00:00">2023-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DPDK/" itemprop="url" rel="index"><span itemprop="name">DPDK</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文基于DPDK 22.11.2。</p>
<p>本文基于ARM架构。</p>
</blockquote>
<h2 id="environment-abstraction-layer">Environment Abstraction
Layer</h2>
<p>EAL（Environment Abstraction
Layer）负责访问低级资源，比如硬件和内存空间。它为应用和库提供了一个通用接口，隐藏了环境特定的细节。</p>
<h3 id="linux用户空间下的eal">Linux用户空间下的EAL</h3>
<p>在Linux用户空间环境中，DPDK应用利用<code>pthread</code>库，以用户空间应用的身份运行。EAL利用<code>mmap()</code>在<code>hugetlbfs</code>中进行物理内存分配，然后将内存暴露给DPDK服务层，比如<code>mempool</code>库。</p>
<h4 id="初始化和核心启动">初始化和核心启动</h4>
<p>部分初始化是由<code>glibc</code>的<code>start</code>函数完成的，然后就进入了DPDK应用的<code>main()</code>函数。核心的初始化和启动是通过<code>rte_eal_init()</code>函数完成的，<code>rte_eal_init()</code>中使用<code>pthread_self()</code>、<code>pthread_create()</code>、<code>pthread_setaffinity_np()</code>创建执行单元，并分配它到特定的逻辑核。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/linuxapp_launch.svg" class="" alt="EAL在Linux用户态环境中初始化">
<p>内存空间、ring、内存池、LPM表和哈希表等对象的初始化也是在main逻辑核，是整个应用初始化的一部分。这些对象的创建和初始化函数不是线程安全的，但完成初始化之后，这些对象本身是线程安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rte_eal_init():</span><br><span class="line">  lib/eal/include/rte_eal.h</span><br><span class="line">  lib/eal/linux/eal.c</span><br></pre></td></tr></table></figure>
<h4 id="内存映射发现和内存预留">内存映射发现和内存预留</h4>
<p>EAL使用大页完成大块连续物理内存的分配，并且EAL提供了在这块连续内存中预留命名内存空间的API。</p>
<blockquote>
<p>DPDK作为用户空间应用框架，使用DPDK的软件需要处理的是虚拟地址。但是，硬件不能理解用户空间虚拟地址，而是使用IO地址。IO地址可能是物理地址（Physical
Addresses，PA），也可能是IO虚拟地址（IO Virtual Addresses，IOVA）。</p>
<p>DPDK不区分PA和IOVA，而是统一称作IOVA。但是，DPDK会区分PA直接作为IOVA（IOVA
as PA），还是IOVA匹配用户空间虚拟地址（IOVA as VA）这两种情况。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/deep-dive-into-iova-fig01-813747.png" class="" alt="IOVA as PA模式">
<p>IOVA as
PA模式下，分配给DPDK的所有内存区域的IOVA都是实际的PA，并且虚拟内存的布局与物理内存的布局相同。IOVA
as
PA的优势在于适用于所有硬件，并且与内核空间之间也很适配（因为物理地址到内核空间虚拟地址的映射是直接映射）。IOVA
as
PA的缺点之一在于需要root权限，否则无法获取内存区域的真实物理地址。缺点之二是物理内存的布局会影响虚拟内存的布局。如果物理内存碎片化比较严重，那么虚拟内存也会是相同程度的碎片化，从而影响DPDK应用对虚拟内存的使用。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/deep-dive-into-iova-fig03-813747.png" class="" alt="IOVA as VA模式">
<p>IOVA as
VA模式下，物理内存会被重新排列，以匹配虚拟内存空间的布局。DPDK通过内核提供的功能完成这一操作，而内核则是通过IOMMU来完成物理内存重映射的。IOVA
as
VA的优点之一就是无需root权限，之二就是避免物理内存的碎片化影响到虚拟内存。IOVA
as VA的缺点在于需要IOMMU的支持。</p>
<p>VFIO（Virtual Function
I/O）是内核基础设置，可以把设备寄存器和中断暴露给用户空间应用，并且可以利用IOMMU建立IOVA映射。</p>
</blockquote>
<p>DPDK的内存子系统有两种模式，动态模式和传统模式。</p>
<p>动态模式下，DPDK使用的大页数量会随着DPDK应用需求而增减。这种模式下分配的内存不能保证是IOVA连续的。如果需要连续的多页IOVA，建议对所有的物理设备使用VFIO驱动，或使用传统模式。动态模式下也可以使用<code>-m</code>或<code>--socket-mem</code>指定预分配内存的大小，预分配的内存在运行时不会被释放。动态模式下可以使用<code>--single-file-segments</code>命令行参数把多个内存页放在同一个文件中，以满足例如用户空间vhost等应用对于页文件描述符数量的限制。可以使用<code>--socket-limit</code>命令行参数来限制DPDK应用可以使用的内存的最大数量。</p>
<p>传统模式下，EAL会在启动时预留全部内存，然后将其重排为IOVA连续的一大块，并且不会在运行时申请或释放大页。需要使用<code>--legacy-mem</code>EAL命令行参数启用传统模式，如果不用<code>-m</code>或<code>--socket-mem</code>指定大小，那么DPDK将使用所有可用的内存大页。</p>
<p>Linux下可以使用<code>hugetlbfs</code>中的文件或者匿名映射来获取大页。使用多进程时必须使用<code>hugetlbfs</code>，因为多个进程需要映射到同一个大页。EAL会在<code>--huge-dir</code>指定的目录中创建<code>--file-prefix</code>指定前缀的文件。匿名映射模式虽然不支持多进程，但是优点在于不需要root权限。</p>
<h3 id="多线程">多线程</h3>
<p>DPDK通常会在每个核心上绑定一个<code>pthread</code>来避免任务切换导致的性能损失，这可以提供显著的性能提升，但缺少灵活性，而且也不总是高效的。</p>
<p><code>lcore</code>代表EAL线程，在Linux实现中就是<code>pthread</code>。<code>lcore</code>由EAL创建和管理，并负责完成<code>rte_eal_remote_launch</code>发出的工作指令。可以使用<code>--lcores</code>命令行参数来设置<code>lcore</code>的核心亲和性，从而间接完成绑核操作。</p>
<p><code>rte_ring</code>支持多生产者多消费者队列，但是是非抢占式的，即同一个<code>ring</code>同时只能有一个线程进行入队或者出队的操作。如果某个线程A正在进行入队操作，另一个线程B也想要对同一个队列进行入队操作，则B只能等待；如果此时线程A被更高优先级的线程抢占，那么有可能会发生死锁。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/sched.7.html">Linux
CPU调度概览</a></p>
</blockquote>
<p>POSIX API定义了一种概念：异步信号安全函数（async-signal-safe
function），指的是可以安全地在信号处理函数中使用的函数。许多DPDK函数不是可重入的（non-reentrant），因此不是异步信号安全函数。</p>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">异步信号安全函数</a></p>
<p><a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reentrancy_(computing)">可重入</a></p>
<p>举例来说，函数A执行过程中，被更高优先级的任务B（例如中断、信号处理）抢占，而在任务B中又调用了函数A。如果A在这种情况下也能保证正确性，那么A就是可重入的。</p>
</blockquote>
<h3 id="malloc"><code>malloc</code></h3>
<p>EAL提供了<code>malloc</code>
API用于分配任意大小的内存。通常来说，<code>malloc</code>
API不应该在数据面中使用，因为它比基于池（pool-based）的API慢，因为分配和释放过程中使用了锁。</p>
<p><code>malloc</code>库中有两个主要数据结构：</p>
<ul>
<li><code>malloc_heap</code>，用于跟踪每个<code>socket</code>的空闲空间，是一个双向链表。</li>
<li><code>malloc_elem</code>，分配和空闲空间跟踪的基本元素，是链表中的节点。</li>
</ul>
<p><code>malloc_heap</code>中有以下关键字段：</p>
<ul>
<li><code>lock</code>：用于控制同步访问。由于<code>malloc_heap</code>中存放着跟踪空闲空间的链表，因此需要防止多个线程同时对链表进行操作。</li>
<li><code>free_head</code>：指向第一个空闲空间链表节点。</li>
<li><code>first</code>：指向<code>malloc_heap</code>中第一个<code>malloc_elem</code>。</li>
<li><code>last</code>：指向<code>malloc_heap</code>中最后一个<code>malloc_elem</code>。</li>
</ul>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/malloc_heap.svg" class="" alt="&#96;malloc_heap&#96;和&#96;malloc_elem&#96;举例">
<p>由于在动态模式下大页是在运行时向系统申请和释放的，所以相邻的<code>malloc_elem</code>对应的实际内存不一定相邻。并且，横跨多页的<code>malloc_elem</code>中的页也可能不是IOVA连续的，每个<code>malloc_elem</code>只能保证其中的内存是VA连续的。</p>
<p><code>malloc_elem</code>有两种用途，其一是作为空闲或已分配内存的header，其二是作为header
padding。</p>
<p><code>malloc_elem</code>中有以下关键字段：</p>
<ul>
<li><code>heap</code>：指向持有该<code>malloc_elem</code>的<code>malloc_heap</code>的指针。</li>
<li><code>prev</code>、<code>next</code>：指向前一个和后一个元素。当前元素被释放时，可以查看是否可以和前后元素进行合并。</li>
<li><code>free_list</code>：指向前一个和后一个空闲节点。</li>
<li><code>state</code>：可选值有<code>FREE</code>、<code>BUSY</code>、<code>PAD</code>，表示空闲、已使用或者作为padding。</li>
<li><code>dirty</code>：仅在<code>state == FREE</code>时有效，表示内存中的内容不是全部置零的。<code>dirty</code>被置位的情况只会发生在使用<code>--huge-unlink=never</code>命令行参数的时候。</li>
<li><code>pad</code>：保存了padding的长度。</li>
<li><code>size</code>：包含header在内的数据块总长度。</li>
</ul>
<blockquote>
<p>当<code>hugetlbfs</code>中的文件或文件的一部分首次在全系统范围映射时，内核会清空其中的数据，以防止数据泄露。EAL会在启动时删除现有后备文件（backing
file）并重新创建，然后再进行映射，以保证数据被清空。</p>
<p>清空内存占了大页映射总耗时的95%以上，因此可以使用<code>--huge-unlink=never</code>让EAL直接使用现有的后备文件以及其中的数据，从而跳过清空内存的过程。通常<code>--huge-unlink=never</code>用于加快应用重启的速度。</p>
</blockquote>
<p>当<code>malloc_heap</code>中没有足够的空间满足分配请求时，EAL会像系统申请更多内存。任何申请新页的请求都必须经过主进程。如果主进程不活跃，那么无法申请任何新内存。主进程负责决定什么应该被映射、什么不应该被映射。每个次进程都有自己的本地内存映射，但它们不能修改这些映射，只能从主进程拷贝内存映射到本地内存映射。</p>
<h2 id="rcu-library">RCU Library</h2>
<p>RCU（Ready-Copy
Update）是一种无锁同步机制。这个名字的由来指的是写者想要更新数据数据结构中的元素时，需要复制一个元素的副本，然后在副本上修改，最后通过原子操作一次性把副本更新到数据结构中。由于无锁，读者和写者可以同时访问该数据结构，所以当写者从数据结构中删除一个元素时，写者无法确定是否有读者仍持有该元素的引用，所以不能直接释放该元素对应的内存。因此，删除元素的操作需要分为两步：</p>
<ol type="1">
<li>删除。写者从数据结构中删除该元素的引用（这一操作是原子的），但是暂不释放该元素对应的内存。这一步可以防止该元素被新读者访问。</li>
<li>释放。当写者确认已无读者持有该元素的饮用后，就可以释放该元素对应的内存了，此时该元素被彻底删除。</li>
</ol>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/rcu_general_info.svg" class="" alt="静止态">
<p>接下来需要介绍两个概念，静止态和宽限期。线程执行过程中没有持有共享内存的引用的状态称为静止态（quiescent
state）。同一个线程在同一个时刻，可能对于共享内存A来说是静止态，但对于共享内存B来说不是静止态。宽限期（grace
period）则是写者从数据结构中删除元素到所有读者不再持有对该元素的引用的这一段时间。</p>
<p>问题在于，写者如何确定读者是否处于静止态，并且写者要以最低的成本确定读者是否处于静止态。写者需要轮询读者的状态来确定宽限期是否结束，这会导致内存访问，浪费CPU周期。并且在这期间，写者还不能释放元素对应的内存，导致持续的内存占用。</p>
<p>临界区的长度和读者的数量与宽限期的长度成正比。令临界区更小可以让宽限期更短，然而更小的宽限期需要额外的CPU周期。所以，我们需要短宽限期、大临界区。</p>
<p>对DPDK应用来说，在<code>while(1)</code>循环对开始和结束，不持有共享内存的引用，是完美的静止态。把所有共享数据结构访问放入一个单一的大临界区能够将读者侧的同步开销降低到最小。DPDK提供了一个QS变量，可以用于跟踪宽限期的结束，以便缩短宽限期的长度。</p>
<h2 id="ring-library">Ring Library</h2>
<p><code>ring</code>是一种队列，它有以下特点：</p>
<ul>
<li>FIFO。</li>
<li>尺寸固定。</li>
<li>可以保存指针或者其他大小（必须是4字节的倍数）的数据。</li>
<li>无锁实现。</li>
<li>支持多消费者、多生产者。</li>
<li>支持bulk入队出队：一次入队出队多个元素，数量不足时失败。</li>
<li>支持burst入队出队：一次入队出队多个元素，数量不足时尽可能多入队出队。</li>
</ul>
<p><code>ring</code>结构由两对头尾指针组成，一对给生产者使用，一对给消费者使用。</p>
<h3 id="生产者入队">生产者入队</h3>
<p>生产者入队需要四步。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/ring-mp-enqueue1.svg" class="" alt="第一步">
<p>第一步需要把<code>ring-&gt;prod_head</code>和<code>ring-&gt;cons_tail</code>拷贝到本地变量<code>prod_head</code>和<code>cons_tail</code>，用于计算<code>ring</code>中剩余容量。然后创建本地变量<code>prod_next</code>，并指向下一个（或者多个）位置。这一步中还会检查是否有足够的位置来满足该入队操作。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/ring-mp-enqueue2.svg" class="" alt="第二步">
<p>第二步是<code>ring-&gt;prod_head = prod_next</code>，相当于占座儿的操作，从<code>ring-&gt;prod_tail</code>到<code>ring-&gt;prod_head</code>之间的位置可以认为已经被占用，只是对应的数据还没被拷贝进来。这是利用原子操作完成的，“compare
and
set”，当<code>ring-&gt;prod_head == prod_head</code>时设置<code>ring-&gt;prod_head = prod_next</code>。以上图为例，core
1的操作成功了，先占到了位置；core
2只能重新读取<code>ring-&gt;prod_head</code>、<code>ring-&gt;cons_tail</code>，重新计算<code>prod_next</code>。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/ring-mp-enqueue3.svg" class="" alt="第三步">
<p>第三步是把数据拷贝到<code>ring</code>中。core 1和core
2分别向<code>ring</code>中拷贝了<code>obj4</code>和<code>obj5</code>。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/ring-mp-enqueue4.svg" class="" alt="第四步">
<p>第四步是更新<code>ring-&gt;prod_tail = prod_next</code>。这一步也使用了原子操作，当<code>ring-&gt;prod_tail == prod_head</code>时设置<code>ring-&gt;prod_tail = prod_next</code>。以上图为例，core
1成功执行了这个操作，而core 2中原子操作的条件不满足。</p>
<p>然后看看代码。<code>lib/ring/rte_ring.h</code>中提供了多种入队的函数，以<code>rte_ring_enqueue()</code>为例，它是<code>rte_ring_enqueue_elem()</code>的简单包裹，后者是<code>rte_ring_enqueue_bulk_elem()</code>的简单包裹。<code>rte_ring_enqueue_bulk_elem()</code>根据<code>ring</code>的类型不同，调用不同的入队函数。假设<code>ring-&gt;prod.sync_type</code>是<code>RTE_RING_SYNC_MT</code>，即multi-thread
safe类型，这也是默认类型，那么将会调用<code>rte_ring_mp_enqueue_bulk_elem()</code>，该函数会调用<code>__rte_ring_do_enqueue_elem()</code>来完成最终的入队工作。</p>
<p><code>__rte_ring_do_enqueue_elem()</code>参数的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__rte_ring_do_enqueue_elem(</span><br><span class="line">  <span class="keyword">struct</span> rte_ring *r,       <span class="comment">// ring</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *obj_table,    <span class="comment">// 待入队数据构成的数组</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> esize,       <span class="comment">// 元素的尺寸，必须是4的倍数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n,           <span class="comment">// 待入队元素的数量</span></span><br><span class="line">  <span class="keyword">enum</span> rte_ring_queue_behavior behavior,</span><br><span class="line">                            <span class="comment">// 入队固定数量的元素，否则报错（插入单个元素和bulk模式）</span></span><br><span class="line">                            <span class="comment">// 还是尽可能多地入队数据，不报错（burst模式）</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> is_sp,       <span class="comment">// 是否只有一个生产者</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *free_space) <span class="comment">// 如果不为NULL，那么会被设置为入队完成后ring的剩余容量</span></span><br></pre></td></tr></table></figure>
<p>解开层层包裹，最终上述函数的参数是<code>__rte_ring_do_enqueue_elem(r, obj_table, sizeof(void *), 1, RTE_RING_QUEUE_FIXED, RTE_RING_SYNC_MT, NULL)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">uint32_t</span> prod_head, prod_next;</span><br><span class="line">  <span class="type">uint32_t</span> free_entries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一步、第二步</span></span><br><span class="line">  n = __rte_ring_move_prod_head(r, is_sp, n, behavior,</span><br><span class="line">      &amp;prod_head, &amp;prod_next, &amp;free_entries);</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三步</span></span><br><span class="line">  __rte_ring_enqueue_elems(r, prod_head, obj_table, esize, n);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第四步</span></span><br><span class="line">  __rte_ring_update_tail(&amp;r-&gt;prod, prod_head, prod_next, is_sp, <span class="number">1</span>);</span><br><span class="line">end:</span><br><span class="line">  <span class="keyword">if</span> (free_space != <span class="literal">NULL</span>)</span><br><span class="line">    *free_space = free_entries - n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br></pre></td></tr></table></figure>
<p>然后看第一个函数<code>__rte_ring_move_prod_head()</code>。</p>
<div class="note warning"><h4
id="疑问__rte_ring_move_prod_head">疑问：<code>__rte_ring_move_prod_head()</code></h4>
<ul>
<li>ARM内存屏障指令的共享域起什么作用？</li>
<li><code>rte_smp_rmb()</code>内存屏障在保护什么东西？</li>
</ul>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__rte_ring_move_prod_head(<span class="keyword">struct</span> rte_ring *r, <span class="type">unsigned</span> <span class="type">int</span> is_sp,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior,</span><br><span class="line">    <span class="type">uint32_t</span> *old_head, <span class="type">uint32_t</span> *new_head,</span><br><span class="line">    <span class="type">uint32_t</span> *free_entries)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> capacity = r-&gt;capacity;</span><br><span class="line">  <span class="comment">// 记录想要入队多少数据，接下来会计算能够入队多少数据，</span></span><br><span class="line">  <span class="comment">// 并保存在n中，然后会比较max和n，根据不同的入队策略执行不同的动作。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> max = n;</span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重试循环，执行成功就退出循环，失败则继续循环</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* Reset n to the initial burst count */</span></span><br><span class="line">    <span class="comment">// 重设n和old_head。n是想要入队的数据数量，old_head是当前的ring-&gt;prod_head</span></span><br><span class="line">    n = max;</span><br><span class="line"></span><br><span class="line">    *old_head = r-&gt;prod.head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add rmb barrier to avoid load/load reorder in weak</span></span><br><span class="line"><span class="comment">     * memory model. It is noop on x86</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 在ARM架构中，这实际上是一条dmb ishld指令，能够保证这条指令之前的所有读指令都完成后，</span></span><br><span class="line">    <span class="comment">// 才能执行这条指令之后的内存访问（包括读写）指令。 ish指的是inner shareable domain，</span></span><br><span class="line">    <span class="comment">// 可理解为整个机器范围，也就是所有核心上执行的指令中，这条指令之前的读指令执行完成后，</span></span><br><span class="line">    <span class="comment">// 才能执行这条指令之后的内存访问指令。所以这条指令在防谁呢？</span></span><br><span class="line">    rte_smp_rmb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  The subtraction is done between two unsigned 32bits value</span></span><br><span class="line"><span class="comment">     * (the result is always modulo 32 bits even if we have</span></span><br><span class="line"><span class="comment">     * *old_head &gt; cons_tail). So &#x27;free_entries&#x27; is always between 0</span></span><br><span class="line"><span class="comment">     * and capacity (which is &lt; size).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// prod.head，prod.tail，cons.head，cons.tail四个索引的范围并不是[0,r-&gt;size)，</span></span><br><span class="line">    <span class="comment">// 而是[0,2^32)，每当需要使用这些索引时，将进行index&amp;(size-1)，来得到合法的索引。</span></span><br><span class="line">    <span class="comment">// 当然，这样以来size必须是2的幂了，但优点在于不必再判断各种边界条件。capacity是ring</span></span><br><span class="line">    <span class="comment">// 中真正可用的entry数量，等于size-1。留一个位置不用的原因应该是为了方便区分空ring和满ring，</span></span><br><span class="line">    <span class="comment">// 否则这两种情况都是prod==cons，不好分辨。所以在创建时设置容量为1024，实际上会得到容量为</span></span><br><span class="line">    <span class="comment">// 1023的ring。当然，可以在创建ring时强制不使用2的幂作为容量，如此以来size会被设置为</span></span><br><span class="line">    <span class="comment">// 大于该容量的最近的2的幂（最坏情况下要浪费一半的空间），capacity会被设置为指定的容量。</span></span><br><span class="line">    <span class="comment">// 另外，这capacity个可用位置并不是固定在ring的某个位置，比如固定前capacity个位置可用，</span></span><br><span class="line">    <span class="comment">// 其他位置留作他用。capacity仅仅是一个数字限制，入队元素时用作检查，数据还是在ring的</span></span><br><span class="line">    <span class="comment">// 整个size内入队出队的。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 四个索引逻辑上只会前进（增加）而不会后退（减少），实际上只会在到达2^32范围时重新回到0。</span></span><br><span class="line">    <span class="comment">// 下列式子无论是在正常情况下，还是cons.tail位于接近2^32的位置而prod.head已经回到0附近</span></span><br><span class="line">    <span class="comment">// 的情况下，都能利用32位无符号数的溢出计算出正确的结果。</span></span><br><span class="line">    *free_entries = (capacity + r-&gt;cons.tail - *old_head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that we have enough room in ring */</span></span><br><span class="line">    <span class="comment">// unlikely()和likely()可以告诉编译器这个判断更可能为false或true，从而可以对分支预测</span></span><br><span class="line">    <span class="comment">// 进行优化。这里根据入队策略设置了n的值，如果是必须入队固定数量的策略，那么空闲entry不足时</span></span><br><span class="line">    <span class="comment">// 不进行入队，直接返回；如果是尽可能入队的策略，那么根据空闲entry数量调整n的值。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(n &gt; *free_entries))</span><br><span class="line">      n = (behavior == RTE_RING_QUEUE_FIXED) ?</span><br><span class="line">          <span class="number">0</span> : *free_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的prod.head位置，如果是单线程模式，直接更新并设置success为真，否则，使用原子操作</span></span><br><span class="line">    <span class="comment">// 来更新，如果失败则重新进行上述循环。</span></span><br><span class="line">    *new_head = *old_head + n;</span><br><span class="line">    <span class="keyword">if</span> (is_sp)</span><br><span class="line">      r-&gt;prod.head = *new_head, success = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      success = rte_atomic32_cmpset(&amp;r-&gt;prod.head,</span><br><span class="line">          *old_head, *new_head);</span><br><span class="line">  &#125; <span class="keyword">while</span> (unlikely(success == <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是第二个函数<code>__rte_ring_enqueue_elems()</code>。</p>
<div class="note warning"><h4
id="疑问__rte_ring_enqueue_elems">疑问：<code>__rte_ring_enqueue_elems()</code></h4>
<ul>
<li>为什么单独把元素大小是2x4字节和4x4字节的情况单独拿出来了？</li>
<li>复制函数中的循环为什么非要每次循环复制32字节？</li>
<li>为什么到4x4字节的情况中忽然换成了<code>memcpy()</code>函数来复制？</li>
</ul>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line">__rte_ring_enqueue_elems(<span class="keyword">struct</span> rte_ring *r, <span class="type">uint32_t</span> prod_head,</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *obj_table, <span class="type">uint32_t</span> esize, <span class="type">uint32_t</span> num)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 8B and 16B copies implemented individually to retain</span></span><br><span class="line"><span class="comment">   * the current performance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 根据元素的大小调用不同的复制函数，果然优化到了极致。8字节和16字节的复制有</span></span><br><span class="line">  <span class="comment">// 专门的函数进行处理，而其他大小的数据都使用4字节对应的函数，内部应该是一个循环。</span></span><br><span class="line">  <span class="keyword">if</span> (esize == <span class="number">8</span>)</span><br><span class="line">    __rte_ring_enqueue_elems_64(r, prod_head, obj_table, num);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (esize == <span class="number">16</span>)</span><br><span class="line">    __rte_ring_enqueue_elems_128(r, prod_head, obj_table, num);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> idx, scale, nr_idx, nr_num, nr_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normalize to uint32_t */</span></span><br><span class="line">    <span class="comment">// scale：元素大小是多少个4字节</span></span><br><span class="line">    <span class="comment">// nr_num：复制全部元素需要复制多少次4字节</span></span><br><span class="line">    <span class="comment">// idx：ring中目标起始位置</span></span><br><span class="line">    <span class="comment">// nr_idx：逻辑索引值（步长是每个元素）乘以每个元素的大小（单位是4字节），</span></span><br><span class="line">    <span class="comment">//       从而获得真实的索引值（单位是4字节）</span></span><br><span class="line">    <span class="comment">// nr_size：逻辑ring大小（单位是元素数量）乘以每个元素的大小（单位是4字节），从</span></span><br><span class="line">    <span class="comment">//        而获得真实的ring大小（单位是4字节）</span></span><br><span class="line">    scale = esize / <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">    nr_num = num * scale;</span><br><span class="line">    idx = prod_head &amp; r-&gt;mask;</span><br><span class="line">    nr_idx = idx * scale;</span><br><span class="line">    nr_size = r-&gt;size * scale;</span><br><span class="line">    __rte_ring_enqueue_elems_32(r, nr_size, nr_idx,</span><br><span class="line">        obj_table, nr_num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line">__rte_ring_enqueue_elems_32(<span class="keyword">struct</span> rte_ring *r, <span class="type">const</span> <span class="type">uint32_t</span> size,</span><br><span class="line">    <span class="type">uint32_t</span> idx, <span class="type">const</span> <span class="type">void</span> *obj_table, <span class="type">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// size = nr_size</span></span><br><span class="line">  <span class="comment">// idx = nr_idx</span></span><br><span class="line">  <span class="comment">// n = nr_num</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// &amp;r[1]相当于一个指针，指向((char*)r) + sizeof(*r)的位置，举例来说，假设r指向的结构体</span></span><br><span class="line">  <span class="comment">// 占用的内存是0x20~0x36，那么&amp;r[1]相当于一个指向0x37的、类型与r相同的指针。然后强制转换</span></span><br><span class="line">  <span class="comment">// 成了uint32t的指针，可以推断出内存布局：每个ring在内存中都是以rte_ring结构体作为header，</span></span><br><span class="line">  <span class="comment">// 后面紧挨着ring中实际数据组成的数组。</span></span><br><span class="line">  <span class="type">uint32_t</span> *ring = (<span class="type">uint32_t</span> *)&amp;r[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> *obj = (<span class="type">const</span> <span class="type">uint32_t</span> *)obj_table;</span><br><span class="line">  <span class="comment">// 判断一下有没有到达数组的末尾，到达了需要回到数组头部</span></span><br><span class="line">  <span class="keyword">if</span> (likely(idx + n &lt;= size)) &#123;</span><br><span class="line">    <span class="comment">// 回忆一下，n的意思是要复制多少次4字节，每次循环可以复制8个4字节。这里是在优化什么？</span></span><br><span class="line">    <span class="comment">// 1. 每次循环多复制几次，可以减少循环跳转的次数，降低跳转和预测错误带来的性能损失。</span></span><br><span class="line">    <span class="comment">// 2. cache对齐？但是cache一般不都是64字节一行吗？</span></span><br><span class="line">    <span class="comment">// 3. prefetch？</span></span><br><span class="line">    <span class="comment">// 想不到其他的了……</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n &amp; ~<span class="number">0x7</span>); i += <span class="number">8</span>, idx += <span class="number">8</span>) &#123;</span><br><span class="line">      ring[idx] = obj[i];</span><br><span class="line">      ring[idx + <span class="number">1</span>] = obj[i + <span class="number">1</span>];</span><br><span class="line">      ring[idx + <span class="number">2</span>] = obj[i + <span class="number">2</span>];</span><br><span class="line">      ring[idx + <span class="number">3</span>] = obj[i + <span class="number">3</span>];</span><br><span class="line">      ring[idx + <span class="number">4</span>] = obj[i + <span class="number">4</span>];</span><br><span class="line">      ring[idx + <span class="number">5</span>] = obj[i + <span class="number">5</span>];</span><br><span class="line">      ring[idx + <span class="number">6</span>] = obj[i + <span class="number">6</span>];</span><br><span class="line">      ring[idx + <span class="number">7</span>] = obj[i + <span class="number">7</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不够8个4字节的，单独每四个字节复制一下</span></span><br><span class="line">    <span class="keyword">switch</span> (n &amp; <span class="number">0x7</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      ring[idx++] = obj[i++]; <span class="comment">/* fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      ring[idx++] = obj[i++]; <span class="comment">/* fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      ring[idx++] = obj[i++]; <span class="comment">/* fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      ring[idx++] = obj[i++]; <span class="comment">/* fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      ring[idx++] = obj[i++]; <span class="comment">/* fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      ring[idx++] = obj[i++]; <span class="comment">/* fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      ring[idx++] = obj[i++]; <span class="comment">/* fallthrough */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果入队数据分别在数组头尾，那就简单地用个循环复制一下。这里怎么不优化了？</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; idx &lt; size; i++, idx++)</span><br><span class="line">      ring[idx] = obj[i];</span><br><span class="line">    <span class="comment">/* Start at the beginning */</span></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; i &lt; n; i++, idx++)</span><br><span class="line">      ring[idx] = obj[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line">__rte_ring_enqueue_elems_64(<span class="keyword">struct</span> rte_ring *r, <span class="type">uint32_t</span> prod_head,</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *obj_table, <span class="type">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">    <span class="comment">// 这里保持了32字节的大小，这个大小有什么特殊性？</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n &amp; ~<span class="number">0x3</span>); i += <span class="number">4</span>, idx += <span class="number">4</span>) &#123;</span><br><span class="line">      ring[idx] = obj[i];</span><br><span class="line">      ring[idx + <span class="number">1</span>] = obj[i + <span class="number">1</span>];</span><br><span class="line">      ring[idx + <span class="number">2</span>] = obj[i + <span class="number">2</span>];</span><br><span class="line">      ring[idx + <span class="number">3</span>] = obj[i + <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line">__rte_ring_enqueue_elems_128(<span class="keyword">struct</span> rte_ring *r, <span class="type">uint32_t</span> prod_head,</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *obj_table, <span class="type">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> size = r-&gt;size;</span><br><span class="line">  <span class="type">uint32_t</span> idx = prod_head &amp; r-&gt;mask;</span><br><span class="line">  <span class="type">rte_int128_t</span> *ring = (<span class="type">rte_int128_t</span> *)&amp;r[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">rte_int128_t</span> *obj = (<span class="type">const</span> <span class="type">rte_int128_t</span> *)obj_table;</span><br><span class="line">  <span class="keyword">if</span> (likely(idx + n &lt;= size)) &#123;</span><br><span class="line">    <span class="comment">// 震惊，这里换成了memcpy，但是还是保持了32字节的大小。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n &amp; ~<span class="number">0x1</span>); i += <span class="number">2</span>, idx += <span class="number">2</span>)</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="type">void</span> *)(ring + idx),</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)(obj + i), <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">switch</span> (n &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="type">void</span> *)(ring + idx),</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)(obj + i), <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; idx &lt; size; i++, idx++)</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="type">void</span> *)(ring + idx),</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)(obj + i), <span class="number">16</span>);</span><br><span class="line">    <span class="comment">/* Start at the beginning */</span></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; i &lt; n; i++, idx++)</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="type">void</span> *)(ring + idx),</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)(obj + i), <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是第三个函数<code>__rte_ring_update_tail()</code>。</p>
<div class="note warning"><h4
id="疑问__rte_ring_update_tail">疑问：<code>__rte_ring_update_tail()</code></h4>
<ul>
<li>显式使用了<code>ldxr</code>之后，编译器会自动在后续匹配一个<code>stxr</code>吗？</li>
<li>如果不是的话，那么对exclusive的内存地址使用<code>str</code>也能触发对core的唤醒事件吗？</li>
</ul>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line">__rte_ring_update_tail(<span class="keyword">struct</span> rte_ring_headtail *ht, <span class="type">uint32_t</span> old_val,</span><br><span class="line">    <span class="type">uint32_t</span> new_val, <span class="type">uint32_t</span> single, <span class="type">uint32_t</span> enqueue)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果是要入队的话，那么加一个写屏障，dmb ishst，也就是等待写操作都完成之后，</span></span><br><span class="line">  <span class="comment">// 再更新prod.tail，防止prod.tail先被写入了，导致消费者直接开始消费空位置。</span></span><br><span class="line">  <span class="keyword">if</span> (enqueue)</span><br><span class="line">    rte_smp_wmb();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    rte_smp_rmb();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * If there are other enqueues/dequeues in progress that preceded us,</span></span><br><span class="line"><span class="comment">   * we need to wait for them to complete</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!single)</span><br><span class="line">    <span class="comment">// 阻塞，直到r-&gt;prod_tail等于prod_head</span></span><br><span class="line">    rte_wait_until_equal_32(&amp;ht-&gt;tail, old_val, __ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里不需要原子操作，因为满足上面判断条件的生产者只可能有一个。</span></span><br><span class="line">  ht-&gt;tail = new_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rte_wait_until_equal_32</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *addr, <span class="type">uint32_t</span> expected,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> memorder)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不满足条件时，编译时会报错。这是C++关于原子操作的一些定义。</span></span><br><span class="line">  RTE_BUILD_BUG_ON(memorder != __ATOMIC_ACQUIRE &amp;&amp;</span><br><span class="line">    memorder != __ATOMIC_RELAXED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在__ATOMIC_RELAXED模式下，相当于一条ldxr指令。ldxr指令会读取内存数据到寄存器，并且</span></span><br><span class="line">  <span class="comment">// 把该内存地址标记为exclusive。stxr指令可以把数据写入标记为exclusive的内存位置，并将该</span></span><br><span class="line">  <span class="comment">// 内存地址标记为open。如果对一个open的内存地址使用stxr，那么会失败，代表是否成功的结果会</span></span><br><span class="line">  <span class="comment">// 保存在指定的寄存器中。ldxr和stxr指令配合使用，可以实现原子操作。假如线程A想要原子地进行</span></span><br><span class="line">  <span class="comment">// i++操作，那么可以使用ldxr进行读取，此时该内存地址被标记为exclusive。然后线程A计算了i+1</span></span><br><span class="line">  <span class="comment">// 的值。此时，线程B使用stxr指令将i设置为了一个新的值，此时该内存地址变为了open。线程A并</span></span><br><span class="line">  <span class="comment">// 不知道其他线程对i的操作，继续使用stxr指令将i+1保存到i，但发现失败了，因为该地址是open。</span></span><br><span class="line">  <span class="comment">// 因此线程A重新使用ldxr读取i、计算i+1、使用stxr进行保存，如此循环。</span></span><br><span class="line">  __RTE_ARM_LOAD_EXC_32(addr, value, memorder)</span><br><span class="line">  <span class="keyword">if</span> (value != expected) &#123;</span><br><span class="line">    <span class="comment">// 如果r-&gt;prod_tail等于prod_head不相等，说明有另一个生产者正在进行操作，那么短暂地</span></span><br><span class="line">    <span class="comment">// 等待一会儿。__RTE_ARM_SEVL()是一条sevl指令，这条指令让当前core从低功耗状态退出。</span></span><br><span class="line">    __RTE_ARM_SEVL()</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// __RTE_ARM_WFE()相当于一条wfe（Wait For Event）指令，这条指令可以让当前core</span></span><br><span class="line">      <span class="comment">// 进入低功耗状态。</span></span><br><span class="line">      __RTE_ARM_WFE()</span><br><span class="line">      <span class="comment">// 重复读取，直到满足条件。当全局监视器标记的对某段内存的exclusive访问被清空时，将向</span></span><br><span class="line">      <span class="comment">// 标记了对该段内存独占访问的核都发送事件。举例来说，当某个核A使用ldxr指令读取某个内存</span></span><br><span class="line">      <span class="comment">// 时，全局监视器中会将该段内存标记为exclusive，然后核A使用wfe进入了低功耗模式，此时</span></span><br><span class="line">      <span class="comment">// 有一个核B使用stxr对该内存进行了写入，将清空全局监视器对这段内存的exclusive标记，</span></span><br><span class="line">      <span class="comment">// 那么核A将收到事件，从而被唤醒。因此，上面的wfe指令不需要对应的sevl指令来唤醒。</span></span><br><span class="line">      <span class="comment">// 问题在于，没有发现显式地使用过stxr，难道说编译器会进行自动转换？还是说str也能唤醒？</span></span><br><span class="line">      <span class="comment">// 不然岂不是每次出队后，都会停在低功耗状态？</span></span><br><span class="line">      __RTE_ARM_LOAD_EXC_32(addr, value, memorder)</span><br><span class="line">    &#125; <span class="keyword">while</span> (value != expected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者出队">消费者出队</h3>
<p>出队的步骤和入队类似。第一步也是将<code>ring-&gt;cons_head</code>拷贝到本地的<code>cons_head</code>，并创建<code>cons_next</code>。第二步是令<code>ring-&gt;cons_head = cons_next</code>，从<code>ring-&gt;cons_tail</code>到<code>ring-&gt;cons_head</code>间的数据就被当前消费者预定了，等待被拷贝出去。第三步是将数据拷贝出来。第四步是令<code>ring-&gt;cons_tail = cons_next</code>。</p>
<p>直接看代码吧。<code>lib/ring/rte_ring.h</code>中提供的出队函数也是多种多样的，单线程、多线程、bulk、burst等。以<code>rte_ring_dequeue()</code>为例，它是<code>rte_ring_enqueue_elem()</code>的简单包裹，后者是<code>rte_ring_dequeue_bulk_elem()</code>的简单包裹。在这个函数中，根据<code>ring</code>类型的不同，调用了不同的出队函数。假设<code>ring-&gt;cons.sync_type == RTE_RING_SYNC_MT</code>，即multi-thread
safe类型，那么会调用<code>rte_ring_mc_dequeue_bulk_elem()</code>，该函数会调用<code>__rte_ring_do_dequeue_elem()</code>来完成出队操作。</p>
<p><code>__rte_ring_do_dequeue_elem()</code>参数的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__rte_ring_do_dequeue_elem(</span><br><span class="line">  <span class="keyword">struct</span> rte_ring *r,   <span class="comment">// ring</span></span><br><span class="line">  <span class="type">void</span> *obj_table,      <span class="comment">// 出队的数据将被放在这里</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> esize,   <span class="comment">// 元素的尺寸，必须是4的倍数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n,       <span class="comment">// 待出队元素的数量</span></span><br><span class="line">  <span class="keyword">enum</span> rte_ring_queue_behavior behavior,</span><br><span class="line">                        <span class="comment">// 出队固定数量的元素，否则报错（插入单个元素和bulk模式）</span></span><br><span class="line">                        <span class="comment">// 还是尽可能多地出队数据，不报错（burst模式）</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> is_sc,   <span class="comment">// 是否只有一个消费者</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *available)</span><br><span class="line">                        <span class="comment">// 如果不为NULL，那么会被设置为出队完成后ring中剩余元素的数量</span></span><br></pre></td></tr></table></figure>
<p>解开层层包裹，最终上述函数的参数是<code>__rte_ring_do_dequeue_elem(r, obj_table, sizeof(void *), 1, RTE_RING_QUEUE_FIXED, RTE_RING_SYNC_MT, NULL)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__rte_ring_do_dequeue_elem(<span class="keyword">struct</span> rte_ring *r, <span class="type">void</span> *obj_table,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> esize, <span class="type">unsigned</span> <span class="type">int</span> n,</span><br><span class="line">    <span class="keyword">enum</span> rte_ring_queue_behavior behavior, <span class="type">unsigned</span> <span class="type">int</span> is_sc,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *available)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> cons_head, cons_next;</span><br><span class="line">  <span class="type">uint32_t</span> entries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一步和第二步</span></span><br><span class="line">  n = __rte_ring_move_cons_head(r, (<span class="type">int</span>)is_sc, n, behavior,</span><br><span class="line">      &amp;cons_head, &amp;cons_next, &amp;entries);</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三步</span></span><br><span class="line">  __rte_ring_dequeue_elems(r, cons_head, obj_table, esize, n);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第四步</span></span><br><span class="line">  __rte_ring_update_tail(&amp;r-&gt;cons, cons_head, cons_next, is_sc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  <span class="keyword">if</span> (available != <span class="literal">NULL</span>)</span><br><span class="line">    *available = entries - n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看第一个函数，<code>__rte_ring_move_cons_head()</code>与<code>__rte_ring_move_prod_head()</code>非常相似。</p>
<div class="note warning"><h4
id="疑问__rte_ring_move_cons_head">疑问：<code>__rte_ring_move_cons_head()</code></h4>
<ul>
<li>单消费者模式下为什么还额外加了个读屏障？</li>
</ul>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __rte_always_inline <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">__rte_ring_move_cons_head(<span class="keyword">struct</span> rte_ring *r, <span class="type">unsigned</span> <span class="type">int</span> is_sc,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n, <span class="keyword">enum</span> rte_ring_queue_behavior behavior,</span><br><span class="line">    <span class="type">uint32_t</span> *old_head, <span class="type">uint32_t</span> *new_head,</span><br><span class="line">    <span class="type">uint32_t</span> *entries)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> max = n;</span><br><span class="line">  <span class="type">int</span> success;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* move cons.head atomically */</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* Restore n as it may change every loop */</span></span><br><span class="line">    n = max;</span><br><span class="line"></span><br><span class="line">    *old_head = r-&gt;cons.head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add rmb barrier to avoid load/load reorder in weak</span></span><br><span class="line"><span class="comment">     * memory model. It is noop on x86</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 注意这里保证的是先读cons.head，后读prod.tail，与入队时正好相反，但是这是在保护什么？</span></span><br><span class="line">    rte_smp_rmb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The subtraction is done between two unsigned 32bits value</span></span><br><span class="line"><span class="comment">     * (the result is always modulo 32 bits even if we have</span></span><br><span class="line"><span class="comment">     * cons_head &gt; prod_tail). So &#x27;entries&#x27; is always between 0</span></span><br><span class="line"><span class="comment">     * and size(ring)-1.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *entries = (r-&gt;prod.tail - *old_head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the actual entries for dequeue */</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; *entries)</span><br><span class="line">      n = (behavior == RTE_RING_QUEUE_FIXED) ? <span class="number">0</span> : *entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(n == <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *new_head = *old_head + n;</span><br><span class="line">    <span class="keyword">if</span> (is_sc) &#123;</span><br><span class="line">      r-&gt;cons.head = *new_head;</span><br><span class="line">      <span class="comment">// 只有一个消费者的时候为什么还要加这个屏障？</span></span><br><span class="line">      rte_smp_rmb();</span><br><span class="line">      success = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      success = rte_atomic32_cmpset(&amp;r-&gt;cons.head, *old_head,</span><br><span class="line">          *new_head);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (unlikely(success == <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是第二个函数，<code>__rte_ring_dequeue_elems()</code>与<code>__rte_ring_enqueue_elems()</code>完全地镜像，这里不水字数了。</p>
<p>第三个函数<code>__rte_ring_update_tail()</code>与入队时使用的是同一个函数，只是参数有所不同。区别在于函数开头用的不是写屏障，而是一个<code>rte_smp_rmb()</code>读屏障。这应该是防止读取尚未完成时，<code>ring-&gt;cons.tail</code>就移动了，导致尚未读取出来的数据有被新入队的数据覆盖的风险。</p>
<h3 id="同步模式">同步模式</h3>
<p>除了默认的多生产者/多消费者模式，还有单生产者单消费者模式。另外，还有RTS（Relaxed
Tail Sync）模式和HTS（Head/Tail Sync）模式。</p>
<p>可以注意到，上文中的代码在修改<code>tail</code>会等待<code>ring-&gt;(prod|cons).head</code>等于本地的<code>head</code>，在等待过程中不断spin。RTS模式可以不进行这种等待，而可以直接修改<code>tail</code>指针到更新的值。这可以在过载的系统（overcommitted
system）中提升出入队的性能。</p>
<p>HTS模式中，出队和入队的操作是完全串行的，同一时刻只能有一个生产者和消费者执行入队和出队操作。在这种模式和单生产者单消费者模式下，<code>ring</code>还提供了<code>peek</code>的API。</p>
<h2 id="mempool-library">Mempool Library</h2>
<blockquote>
<p>DIMM（Dual In-line Memory
Module）是双列直插式内存模块，就是通常所说的“内存条”，双列指的是正反两面的“金手指”是不同的电路，而单列的内存条正反面的金手指是直接相连的相同的冗余电路。直插应该说的是直接怼进去的安装方式吧。SO-DIMM（Small
Outline
DIMM）是小外形DIMM，就是部分笔记本电脑上用的可以插拔的内存条，比台式机内存条更小一些。DIMM说的是物理外形，与内存条具体是DDR几代等各种参数都无直接关系。</p>
<p>CS（Chip
Select）是数字电路设计时常用的一种控制信号，可以从多个集成电路（通常称为chip）中选择一个或一组。一条DIMM上一般都有许多DRAM芯片，而能被同一个CS信号选择出的一组DRAM芯片被称为一个rank。一般来说，一条DIMM有两个rank，正面一个，反面一个，但是这只是惯例，也可以不这样。大多数DIMM上的所有DRAM芯片共享控制信号和数据针脚，但不共享CS信号。因此，同一条DIMM上的多个rank是无法同时被访问的。</p>
<p>以DDR4为例，每个rank数据位宽是64位。如果每个rank有8个芯片，那么每个芯片的位宽就是8位。如果每个rank只有4个芯片，那么每个芯片的位宽就是16位。芯片中有多个bank，每个bank都是一个二维矩阵，矩阵的每个位置都保存着数据，一般是4位、8位或16位，与芯片的位宽相同。每次访问时，都会选择一个rank，然后到每个芯片中找到同一个bank（同一个指的是索引值）的同一行的同一个cell，读出数据，然后把来自所有芯片的数据拼起来，得到64位数据。内存一般还有burst读取的特性，即读取某个地址时，可以一次性读取从这个地址开始的数个cell中的数据。</p>
</blockquote>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/memory-management.svg" class="" alt="内存排布">
<p>如上图所示，是一个2 channel、4
rank的例子。随着内存地址的增长，实际对应的物理位置是按先rank后channel的顺序遍历的，即channel
0的rank 0、channel 1的rank 0、channel 1的rank 0、channel 1的rank
1等等。</p>
<p>当主要任务是L3转发或者流量分类时，只需要读取每个包的前64字节数据。因此如果适当进行padding，使包的起始位置位于不同的channel和rank，就能显著提升（greatly
improved）性能表现。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/mempool.svg" class="" alt="内存池">
<p>默认<code>mempool</code>的底层实现是<code>ring</code>。当多个核心访问内存池的空闲区时，由于需要大量原子CAS操作，可能导致性能下降。因此，内存池分配器为每个核心维护了一个cache。每个核心都能完全访问自己cache中的对象（带锁），当cache的空间不足或多余时，cache才会与内存池间交互，从内存池获取内存或将内存放回内存池。</p>
<h2 id="mbuf-library">Mbuf Library</h2>
<p><code>mbuf</code>提供了分配和释放缓冲区的能力，一般用作网络包缓存，但也可以用于存放任意数据。<code>mbuf</code>的底层实现使用了<code>mempool</code>。<code>rte_mbuf</code>结构体的header保持尽可能地小，当前的大小是两个cache
line，并且最常用的数据放在第一个cache line中。</p>
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/mbuf1.svg" class="" alt="示意图">
<img src="/2023/08/04/DPDK-Programmer-s-Guide%E7%AC%94%E8%AE%B0/mbuf2.svg" class="" alt="示意图">
<p>有两种方法来存储包数据（包括协议头），一是将元数据和包数据放在一起，二是将二者分别放在不同的buffer中。第一种方法的优点是只需一次内存分配和释放操作，第二种方法则更加灵活。DPDK使用了第一种方法，元数据中包含控制信息（消息类型、包文长度、偏移量等）和一个附加的<code>mbuf</code>结构体的指针。当数据包需要占用多个buffer时，可通过<code>mbuf</code>结构体中的指针将其连接起来。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://flyginger.github.io/2023/07/28/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zenk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zenk's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zenk's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/28/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">ELF文件格式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-28 14:47:48" itemprop="dateCreated datePublished" datetime="2023-07-28T14:47:48+00:00">2023-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-14 07:08:19" itemprop="dateModified" datetime="2023-08-14T07:08:19+00:00">2023-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ELF（Executable and Linkable
Format）是一种标准文件格式，支持四种类型的文件：</p>
<ul>
<li>可执行文件（executable file），</li>
<li>目标代码（object code），</li>
<li>共享库（shared library），</li>
<li>核心转储（core dump）。</li>
</ul>
<img src="/2023/07/28/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/elf-layout.svg" class="" alt="ELF文件格式">
<p>ELF文件有两种视图，通过program
header可以访问运行时的segment，通过section header可以访问section。</p>
<p>ELF文件中除了ELF
header必定位于起始位置之外，其他结构的顺序是未定义的。</p>
<h2 id="elf-header">ELF Header</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elf.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 与Elf64_Ehdr完全一致，只是把所有的“64”换成“32”</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off	e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off	e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half	e_phentsize;		<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half	e_shentsize;		<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源代码缩进如此，可不是我搞乱的。</p>
</blockquote>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Size (in byte)</th>
<th style="text-align: left;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Elf32_Half</code>,
<code>Elf64_Half</code></td>
<td style="text-align: left;"><code>uint16_t</code></td>
<td style="text-align: left;">unsigned 16-bit</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Elf32_Word</code>,
<code>Elf64_Word</code></td>
<td style="text-align: left;"><code>uint32_t</code></td>
<td style="text-align: left;">unsigned 32-bit</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Elf32_Sword</code>,
<code>Elf64_Sword</code></td>
<td style="text-align: left;"><code>int32_t</code></td>
<td style="text-align: left;">signed 32-bit</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Elf32_Xword</code>,
<code>Elf64_Xword</code></td>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;">unsigned 64-bit</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Elf32_Sxword</code>,
<code>Elf64_Sxword</code></td>
<td style="text-align: left;"><code>int64_t</code></td>
<td style="text-align: left;">signed 64-bit</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Elf32_Addr</code>,
<code>Elf64_Addr</code></td>
<td style="text-align: left;"><code>uint32_t</code>,
<code>uint64_t</code></td>
<td style="text-align: left;">address</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Elf32_Off</code>,
<code>Elf64_Off</code></td>
<td style="text-align: left;"><code>uint32_t</code>,
<code>uint64_t</code></td>
<td style="text-align: left;">file offset</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Elf32_Section</code>,
<code>Elf64_Section</code></td>
<td style="text-align: left;"><code>uint16_t</code></td>
<td style="text-align: left;">section index</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Elf32_Versym</code>,
<code>Elf64_Versym</code></td>
<td style="text-align: left;"><code>uint16_t</code></td>
<td style="text-align: left;">version symbol information</td>
</tr>
</tbody>
</table>
<p>上表展示了各个数据结构的位宽和作用。在32位和64位模式下，只有<code>Addr</code>和<code>Off</code>的位宽不同，因此<code>Elf32_Ehdr</code>和<code>Elf64_Ehdr</code>分别是52和64字节。</p>
<ul>
<li><code>e_ident</code>：16个字节的标识信息，标识了文件类型、位宽、大小端、版本号等。
<ul>
<li><code>e_ident[EI_MAG0]</code>到<code>e_ident[EI_MAG3]</code>，值为<code>"\177ELF"</code>，表示该文件是一个ELF文件。</li>
<li><code>e_ident[EI_CLASS]</code>，文件类型。
<ul>
<li><code>ELFCLASSNONE</code>：非法类型。</li>
<li><code>ELFCLASS32</code>，32位。</li>
<li><code>ELFCLASS64</code>，64位。</li>
</ul></li>
<li><code>e_ident[EI_DATA]</code>，数据编码。
<ul>
<li><code>ELFDATANONE</code>，非法编码。</li>
<li><code>ELFDATA2LSB</code>，补码，小端</li>
<li><code>ELFDATA2MSB</code>，补码，大端</li>
</ul></li>
<li><code>e_ident[EI_VERSION]</code>，版本号，必须是<code>EV_CURRENT</code>。</li>
<li><code>e_ident[EI_OSABI]</code>，OS ABI标识符。
<ul>
<li>比如<code>ELFOSABI_GNU</code>、<code>ELFOSABI_FREEBSD</code>、<code>ELFOSABI_OPENBSD</code>等。</li>
</ul></li>
<li><code>e_ident[EI_ABIVERSION]</code>，ABI版本。</li>
<li><code>e_ident[EI_PAD]</code>，padding。</li>
</ul></li>
<li><code>e_type</code>：文件类型。
<ul>
<li><code>ET_REL</code>: relocatable file.</li>
<li><code>ET_EXEC</code>: executable file.</li>
<li><code>ET_DYN</code>: shared object file.</li>
<li><code>ET_CORE</code>: core file.</li>
<li>其他依赖于OS或处理的类型。</li>
</ul></li>
<li><code>e_machine</code>：架构信息。
<ul>
<li>比如<code>EM_X86_64</code>、<code>EM_AARCH64</code>等。</li>
</ul></li>
<li><code>e_version</code>：版本号，必须是<code>EV_CURRENT</code>。</li>
<li><code>e_entry</code>：程序执行的起点，entry
point的地址。如果没有entry point，那么置零。</li>
<li><code>e_phoff</code>：指向program header table的指针。</li>
<li><code>e_shoff</code>：指向section header table的指针。</li>
<li><code>e_flags</code>：用于特定处理器的标志。</li>
<li><code>e_ehsize</code>：ELF header的大小，以字节计。</li>
<li><code>e_phentsize</code>：program header
table中每个表项的大小，以字节计。</li>
<li><code>e_phnum</code>：program header table中的表项数量。</li>
<li><code>e_shentsize</code>：section header
table中每个表项的大小，以字节计。</li>
<li><code>e_shnum</code>：section header table中的表项数量。</li>
<li><code>e_shstrndx</code>：section header
table中与section名称相关的表项的索引。</li>
</ul>
<h2 id="section">Section</h2>
<p>ELF文件中的每个section都在section header
table中有对应的表项；反过来，不是每一个表项都对应一个实际的section。每个section在文件中都是连续的，并且不重叠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	sh_name;		<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word	sh_type;		<span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword	sh_flags;		<span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr	sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off	sh_offset;		<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword	sh_size;		<span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word	sh_link;		<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word	sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword	sh_addralign;		<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword	sh_entsize;		<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sh_name</code>：section名称，是section header string table
section的索引。</li>
<li><code>sh_type</code>：section类型。
<ul>
<li><code>SHT_NULL</code>：空section。</li>
<li><code>SHT_PROGBITS</code>：程序自定义的数据。</li>
<li><code>SHT_SYMTAB</code>：符号表。</li>
<li><code>SHT_STRTAB</code>：字符串表。</li>
<li><code>SHT_RELA</code>：可重定位表，有addend。</li>
<li><code>SHT_HASH</code>：符号哈希表。</li>
<li><code>SHT_DYNAMIC</code>：动态链接信息。</li>
<li><code>SHT_NOTE</code>：信息。</li>
<li><code>SHT_NOBITS</code>：没有数据的程序空间。</li>
<li><code>SHT_REL</code>：可重定位表，没有addend。</li>
<li><code>SHT_DYNSYM</code>：动态链接器符号表。</li>
<li>……</li>
</ul></li>
<li><code>sh_flags</code>：标志位。
<ul>
<li><code>SHF_WRITE</code>：可写的。</li>
<li><code>SHF_ALLOC</code>：运行时占用内存。</li>
<li><code>SHF_EXECINSTR</code>：可执行的。</li>
<li>……</li>
</ul></li>
<li><code>sh_addr</code>：运行时section的虚拟地址。运行时不出现在内存映像中的section此字段为0。</li>
<li><code>sh_offset</code>：在ELF文件中的位置，就是从文件头到section起始位置的距离。</li>
<li><code>sh_size</code>：section的长度，单位是字节。</li>
<li><code>sh_link</code>：section header
table中其他section的索引，具体含义随section类型而不同。</li>
<li><code>sh_info</code>：其他section信息。</li>
<li><code>sh_addralign</code>：对齐。必须是0或2的幂，0和1的含义相同。</li>
<li><code>sh_entsize</code>：如果section中有表，此项表示表项的大小。</li>
</ul>
<h3 id="special-section">Special Section</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Flags</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>.bss</code></td>
<td style="text-align: left;"><code>SHT_NOBITS</code></td>
<td style="text-align: left;"><code>SHF_ALLOC | SHF_WRITE</code></td>
<td style="text-align: left;">出现在内存中的未初始化数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.comment</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">版本控制信息。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.data</code>,
<code>.data1</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"><code>SHF_ALLOC | SHF_WRITE</code></td>
<td style="text-align: left;">出现在内存中的初始化过的数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.debug</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">符号调试信息。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.dynamic</code></td>
<td style="text-align: left;"><code>SHT_DYNAMIC</code></td>
<td style="text-align: left;"><code>SHF_ALLOC | SHF_WRITE?</code></td>
<td
style="text-align: left;">动态链接信息。是否<code>SHF_WRITE</code>取决于处理器。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.dynstr</code></td>
<td style="text-align: left;"><code>SHT_STRTAB</code></td>
<td style="text-align: left;"><code>SHF_ALLOC</code></td>
<td style="text-align: left;">用于动态链接的字符串。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.dynsym</code></td>
<td style="text-align: left;"><code>SHT_DYNSYM</code></td>
<td style="text-align: left;"><code>SHF_ALLOC</code></td>
<td style="text-align: left;">动态链接符号表。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.fini</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td
style="text-align: left;"><code>SHF_ALLOC | SHF_EXECINSTR</code></td>
<td style="text-align: left;">进程终止的可执行指令。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.got</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">全局偏移表。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.hash</code></td>
<td style="text-align: left;"><code>SHT_HASH</code></td>
<td style="text-align: left;"><code>SHF_ALLOC</code></td>
<td style="text-align: left;">符号哈希表。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.init</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td
style="text-align: left;"><code>SHF_ALLOC | SHF_EXECINSTR</code></td>
<td style="text-align: left;">进程初始化的可执行指令。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.interp</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">程序解释器的路径名。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.line</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">符号调试的行号信息。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.note</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">注释信息。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.plt</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">Procedure linkage table.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.rel&lt;name&gt;</code>,
<code>.rela&lt;name&gt;</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">重定位信息。</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.rodata</code>,
<code>.rodata1</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td style="text-align: left;"><code>SHF_ALLOC</code></td>
<td style="text-align: left;">只读数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.shstrtab</code></td>
<td style="text-align: left;"><code>SHT_STRTAB</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">节区名称。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.strtab</code></td>
<td style="text-align: left;"><code>SHT_STRTAB</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">字符串表。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.symtab</code></td>
<td style="text-align: left;"><code>SHT_SYMTAB</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">符号表。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.text</code></td>
<td style="text-align: left;"><code>SHT_PROGBITS</code></td>
<td
style="text-align: left;"><code>SHF_ALLOC | SHF_EXECINSTR</code></td>
<td style="text-align: left;">可执行指令。</td>
</tr>
</tbody>
</table>
<h2 id="symbol-table">Symbol Table</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_BIND(val)		(((unsigned char) (val)) &gt;&gt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_TYPE(val)		((val) &amp; 0xf)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_INFO(bind, type)	(((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF64_ST_BIND(val)		ELF32_ST_BIND (val)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>st_name</code>：符号名称，是符号字符串表的索引。</li>
<li><code>st_info</code>：符号类型和绑定信息。
<ul>
<li><code>st_bind</code>：绑定信息，确定链接可见性和行为。
<ul>
<li><code>STB_LOCAL</code>：定义该符号的文件之外不可见。</li>
<li><code>STB_GLOBAL</code>：全局可见，对定义该符号的文件之外也可见。</li>
<li><code>STB_WEAK</code>：与<code>STB_GLOBAL</code>类似，但优先级低。</li>
<li>……</li>
</ul></li>
<li><code>st_type</code>：符号类型。
<ul>
<li><code>stt_object</code>：数据对象，比如变量、数组。</li>
<li><code>stt_func</code>：函数或其他可执行代码。</li>
<li>……</li>
</ul></li>
</ul></li>
<li><code>st_other</code>：符号可见性。</li>
<li><code>st_shndx</code>：section索引。</li>
<li><code>st_value</code>：符号相关的值，具体含义取决于符号。
<ul>
<li>在可重定位文件中，<code>st_value</code>是从<code>st_shndx</code>所指section的虚拟地址起始位置到符号位置的偏移。</li>
<li>在可执行文件和共享库中，<code>st_value</code>是一个虚拟地址。</li>
</ul></li>
<li><code>st_size</code>：符号的尺寸。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://flyginger.github.io/2023/06/27/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zenk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zenk's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zenk's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/27/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Linux内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-27 16:57:25" itemprop="dateCreated datePublished" datetime="2023-06-27T16:57:25+00:00">2023-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-14 07:08:19" itemprop="dateModified" datetime="2023-08-14T07:08:19+00:00">2023-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本概念">基本概念</h2>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/next/admin-guide/mm/concepts.html"
class="uri">https://www.kernel.org/doc/html/next/admin-guide/mm/concepts.html</a></p>
</blockquote>
<h3 id="虚拟内存">虚拟内存</h3>
<p>计算机系统的物理内存是有限的，而且不一定是连续的。虚拟内存可以屏蔽物理内存的这些细节，让每个程序都认为自己可以访问一段独立、连续、完整的内存空间。</p>
<p>使用虚拟内存技术时，CPU需要将虚拟地址翻译为物理地址。物理内存是按页组织的，不同架构上内存页的大小可能不同，典型值是4K。物理页和虚拟页之间存在一对多的映射关系，这种映射关系保存在页表之中。</p>
<p>页表可以是多级结构。最低级页表中保存了最终的物理地址，高级页表中保存的是低一级页表的物理地址。CPU中有一个寄存器，保存了指向最高级页表的指针。</p>
<p>当CPU翻译虚拟地址时，会按从高到低的顺序访问页表。在页表的每一级，截取虚拟地址的高位作为索引，低位传入下一级页表。最终剩下的最低几位代表该地址在这一页内存中的位置。</p>
<h3 id="大页">大页</h3>
<p>对于CPU来说，内存访问是很慢的，将虚拟地址翻译为物理地址需要多次访问内存。为了提高性能，有了TLB（Translation
Lookaside Buffer）的设计，它是页表的缓存。</p>
<p>许多CPU架构允许高级页表直接映射至物理内存（而不是低一级页表）。比如x86，可以在二级和三级页表中使用2M甚至1G的大页。使用大页能够显著地减少TLB
miss。</p>
<p>在Linux中，有两种方式使用大页。第一种是HugeTLB文件系统，也称hugetlbfs，它是一种内存文件系统。hugetlbfs需要用户配置具体哪些内存被映射至大页。</p>
<p>另一种是THP（Transparent HugePages），它无需用户配置。</p>
<h3 id="匿名内存">匿名内存</h3>
<p>匿名内存（anonymous
memory）代表没有对应文件系统的内存，与之对应的是文件和设备映射内存等。通常堆、栈都属于匿名内存。</p>
<h3 id="回收reclaim">回收（Reclaim）</h3>
<p>在系统的生命周期中，单个物理页可能被用于存储不同类型的数据，例如内核的内部数据结构、DMA缓存、从文件系统中读取的数据、用户空间进程分配的内存等。Linux会根据用途区别对待物理页。</p>
<p>某些页起缓存的作用，其中的数据可从其他位置（例如硬盘）再次获取，还有些页中的数据可以被交换出内存，这两类内存页可以随时释放。可以随时释放的页是可回收（reclaimable）页。可回收页主要是页缓存（page
cache）和匿名内存，其中页缓存是内存中对硬盘数据的缓存。</p>
<p>在内存基本没被使用时，Linux系统中的大多数内存分配请求能够立刻被满足。当内存占用达到low
watermask时，内存分配请求会唤醒<code>kswapd</code>后台驻留程序，异步地对可回收页进行回收。当内存占用达到min
watermask后，内存分配请求需要等待系统同步地回收其他内存页，以满足该请求对内存的需求，这称为直接回收。</p>
<h3 id="压缩compaction">压缩（Compaction）</h3>
<p>内存压缩会把内存空间（zone）中较低部分的内存页挪到较高部分，使得内存空间较低部分有连续的大块儿可用内存。</p>
<p>压缩可以通过<code>kcompactd</code>后台驻留程序异步地完成，也可以由内存分配请求触发，同步地完成。</p>
<h2 id="透明大页">透明大页</h2>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html"
class="uri">https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html</a></p>
</blockquote>
<h3 id="目标">目标</h3>
<p>透明大页目前仅支持匿名内存、tmpfs和shmem。tmpfs是一种基于内存的文件系统；shmem是一种进程间通信的方式。</p>
<p>透明大页主要在两方面提升了应用程序的效率。第一是，页错误每次处理的内存大小更大了，从而大幅减少了进入和退出内核态的次数。第二与TLB
miss相关，分为两个方面。首先是TLB
miss的惩罚更低了，因为页表层级变少了。其次是TLB
miss数量降低了，因为每个TLB条目都对应了更大的一片内存。</p>
<p>透明大页可以在系统范围内开启，也可以只为某些任务开启，甚至可以单独为任务内存空间的一部分开启。除非透明大页被完全禁用，否则<code>khugepaged</code>会扫描内存，然后把连续的普通页转换为大页。</p>
<p>透明大页的行为可以通过sysfs接口或者madvise和prctl系统调用来控制。</p>
<h3 id="sysfs">sysfs</h3>
<p>透明大页可以完全禁用（通常为了debug），或只在<code>MADV_HUGEPAGE</code>区域开始（通常用于内存有限的系统中），或者完全开启。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> always &gt;/sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="built_in">echo</span> madvise &gt;/sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="built_in">echo</span> never &gt;/sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>
<p>有时分配透明大页的请求不能被立刻满足，此时可以选择等待，或者直接回收，或者回退到使用普通页。为了分配大页而整理内存需要占用CPU资源，所以我们当然希望物超所值，即分配了大页带来的好处超过占用的CPU资源。</p>
<p>透明大页的<code>defrag</code>配置有以下选项：</p>
<ul>
<li><code>awlays</code>：同步地分配透明大页，即无法立即分配时阻塞，执行回收和压缩动作，从而完成分配。</li>
<li><code>defer</code>：异步地分配透明大页，即唤醒<code>kswapd</code>、<code>kcompactd</code>来异步地完成回收和压缩，然后通过<code>khugepaged</code>分配透明大页。</li>
<li><code>defer+madvise</code>：在<code>MADV_HUGEPAGE</code>区域使用<code>awlays</code>策略，其他区域使用<code>defer</code>策略。</li>
<li><code>madvise</code>：在<code>MADV_HUGEPAGE</code>区域使用<code>awlays</code>策略，其他区域使用<code>never</code>策略。此为默认配置。</li>
<li><code>never</code>：无法立即分配时回退到使用普通页。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> always &gt;/sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"><span class="built_in">echo</span> defer &gt;/sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"><span class="built_in">echo</span> defer+madvise &gt;/sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"><span class="built_in">echo</span> madvise &gt;/sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"><span class="built_in">echo</span> never &gt;/sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure>
<p>内核默认在匿名内存的读页错误发生时使用零页（zero
page），但是这也是可配置的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt;/sys/kernel/mm/transparent_hugepage/use_zero_page</span><br><span class="line"><span class="built_in">echo</span> 1 &gt;/sys/kernel/mm/transparent_hugepage/use_zero_page</span><br></pre></td></tr></table></figure>
<p>通过以下命令可以查看透明大页的尺寸。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/mm/transparent_hugepage/hpage_pmd_size</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://flyginger.github.io/2022/12/01/FFmpeg%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zenk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zenk's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zenk's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/01/FFmpeg%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">FFmpeg命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-01T00:00:00+00:00">2022-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-14 07:08:19" itemprop="dateModified" datetime="2023-08-14T07:08:19+00:00">2023-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="查看硬件支持">查看硬件支持</h2>
<p>使用如下命令可以查看硬件支持、编码器、解码器等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hwaccels</span><br><span class="line">ffmpeg -encoders</span><br><span class="line">ffmpeg -decoders</span><br></pre></td></tr></table></figure>
<p>使用如下命令可以查看单个编码器的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -h encoder=libx265</span><br></pre></td></tr></table></figure>
<h2 id="裁切黑边">裁切黑边</h2>
<p>可以使用<code>cropdetect</code>自动检测黑边，用<code>crop</code>进行黑边裁切。</p>
<p><code>cropdetect</code>后的数值是灵敏度，如果黑边不是纯黑，可以适当提高数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i xxx.mp4 -an -vf cropdetect=20</span><br><span class="line">ffmpeg -i xxx.mp4 -vf crop=xxx</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://flyginger.github.io/2022/04/08/%E5%88%A9%E7%94%A8TTRSS%E6%90%AD%E5%BB%BARSS%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zenk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zenk's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zenk's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/08/%E5%88%A9%E7%94%A8TTRSS%E6%90%AD%E5%BB%BARSS%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">利用TTRSS搭建RSS服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-08T00:00:00+00:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-14 07:08:19" itemprop="dateModified" datetime="2023-08-14T07:08:19+00:00">2023-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">解决方案</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主要介绍白嫖AWS的免费云服务器，利用<a
target="_blank" rel="noopener" href="https://tt-rss.org">Tiny Tiny
RSS</a>来搭建一个RSS服务器的过程。以前我都是使用Inoreader的，但是免费版刷新太慢了，六小时都不给我刷新一次。</p>
<p>现在开始。创建AWS账号、创建实例的过程就跳过了，我选的系统是Ubuntu
20版本，然后就是免费选项选到最后。创建实例之前一定要注意当前的区域，最好在距离近的区域创建实例，这样延迟低一些。</p>
<p>然后需要进行安全组设置。默认只打开了SSH用到的22端口，这肯定是不够的。需要打开HTTP的80端口和HTTPS的443端口。另外，还需要打开181端口，协议用TCP。</p>
<p>接下来，就可以用SSH连接云服务器了。在创建实例的时候，还会让你顺带创建密钥，可以得到一个<code>pem</code>文件。下载到这个文件之后，要先对它执行一个命令。这个命令可以修改它的读写执行的权限（改到最少），如果不改的话，SSH的时候会提示权限太<code>open</code>，不让你连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 400 /path/to/pem_file</span><br></pre></td></tr></table></figure>
<p>接下来就可以SSH了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /path/to/pem_file user_name@server_address</span><br></pre></td></tr></table></figure>
<p><code>user_name</code>和<code>server_address</code>可以在AWS点击“连接”按钮，直接得到。如果你没改过，那么它提供的默认提示就是对的。</p>
<p>进入到系统之后，直接先更新一下<code>apt</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>
<p>然后，安装Docker。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<p>当然，有强迫症的话，安装完了可以<code>rmget-docker.sh</code>。然后，安装Docker
Compose。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>安装命令里带版本号，实在是拉垮，你可以到<a
target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/">这里</a>找到最新的安装命令。安装完可以用<code>docker-compose --version</code>检查一下。</p>
<p>Tiny Tiny RSS并不是一个基于Docker的项目，但是<a
target="_blank" rel="noopener" href="https://ttrss.henry.wang/zh/#关于">Awesome
TTRSS</a>给出了这样一个实现，感谢！</p>
<p>我们使用基于Docker Compose的安装方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ttrss</span><br><span class="line"><span class="built_in">cd</span> ttrss</span><br><span class="line">curl -fLo docker-compose.yml https://raw.githubusercontent.com/HenryQW/Awesome-TTRSS/main/docker-compose.yml</span><br></pre></td></tr></table></figure>
<p>接下来，我们利用<code>nano</code>来修改<code>docker-compose.yml</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano docker-compose.yml</span><br></pre></td></tr></table></figure>
<p>一共要修改三个地方。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.rss:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/ttrss:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ttrss</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">181</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SELF_URL_PATH=http://localhost:181/</span> <span class="comment"># 第一处修改，把地址改成你的域名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=strong_password</span> <span class="comment"># 第二处修改，这里写一个非常强的密码，因为你不需要记住它</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PUID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PGID=1000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">feed-icons:/var/www/feed-icons/</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">public_access</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">service_only</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">database_only</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">service.mercury:</span> <span class="comment"># set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/mercury-parser-api:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mercury</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">public_access</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">service_only</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">service.opencc:</span> <span class="comment"># set OpenCC API endpoint to `service.opencc:3000` on TTRSS plugin setting page</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/opencc-api-server:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">opencc</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NODE_ENV=production</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">service_only</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">database.postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=strong_password</span> <span class="comment"># 第三处修改，改成和第二处一样的密码</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/postgres/data/:/var/lib/postgresql/data</span> <span class="comment"># persist postgres data to ~/postgres/data/ on the host</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">database_only</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># utility.watchtower:</span></span><br><span class="line">  <span class="comment">#   container_name: watchtower</span></span><br><span class="line">  <span class="comment">#   image: containrrr/watchtower:latest</span></span><br><span class="line">  <span class="comment">#   volumes:</span></span><br><span class="line">  <span class="comment">#     - /var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">  <span class="comment">#   environment:</span></span><br><span class="line">  <span class="comment">#     - WATCHTOWER_CLEANUP=true</span></span><br><span class="line">  <span class="comment">#     - WATCHTOWER_POLL_INTERVAL=86400</span></span><br><span class="line">  <span class="comment">#   restart: always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">feed-icons:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">public_access:</span> <span class="comment"># Provide the access for ttrss UI</span></span><br><span class="line">  <span class="attr">service_only:</span> <span class="comment"># Provide the communication network between services only</span></span><br><span class="line">    <span class="attr">internal:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">database_only:</span> <span class="comment"># Provide the communication between ttrss and database only</span></span><br><span class="line">    <span class="attr">internal:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>然后就可以运行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>之后想要修改<code>docker-compose.yml</code>时，先<code>docker-compose down</code>然后修改，改好后重新<code>docker-compose up -d</code>即可。注意以上命令都要在<code>ttrss</code>文件夹内执行。</p>
<p>然后安装Nginx和Certbot来使用HTTPS。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nginx</span><br><span class="line">sudo apt install certbot python3-certbot-nginx</span><br></pre></td></tr></table></figure>
<p>然后可以启动Nginx。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure>
<p>利用Certbot创建证书。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --nginx</span><br></pre></td></tr></table></figure>
<p>按提示输入你的域名。它还会问你是否要把所有流量都转发到HTTPS，请选择是。接下来修改Nginx配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>在<code>http</code>段找到以下两行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br><span class="line">include /etc/nginx/sites-enabled/*;</span><br></pre></td></tr></table></figure>
<p>把这两行注释掉，然后在这两行下面添加以下内容。请把<code>ttrssdev.henry.wang</code>替换成你的域名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">upstream ttrssdev &#123;</span><br><span class="line">    server 127.0.0.1:181;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ttrssdev.henry.wang;</span><br><span class="line">    return 301 https://ttrssdev.henry.wang$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    gzip on;</span><br><span class="line">    server_name  ttrssdev.henry.wang;</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/ttrssdev.henry.wang/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/ttrssdev.henry.wang/privkey.pem;</span><br><span class="line">    access_log /var/log/nginx/ttrssdev_access.log combined;</span><br><span class="line">    error_log  /var/log/nginx/ttrssdev_error.log;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http://ttrssdev;</span><br><span class="line">        proxy_set_header  Host                $http_host;</span><br><span class="line">        proxy_set_header  X-Real-IP           $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-Ssl     on;</span><br><span class="line">        proxy_set_header  X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header  X-Forwarded-Proto   $scheme;</span><br><span class="line">        proxy_set_header  X-Frame-Options     SAMEORIGIN;</span><br><span class="line">        client_max_body_size        100m;</span><br><span class="line">        client_body_buffer_size     128k;</span><br><span class="line">        proxy_buffer_size           4k;</span><br><span class="line">        proxy_buffers               4 32k;</span><br><span class="line">        proxy_busy_buffers_size     64k;</span><br><span class="line">        proxy_temp_file_write_size  64k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，重启Nginx。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>然后访问你的域名即可。记得改掉admin的密码，然后在用户里创建一个普通用户来使用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zenk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
